# ProfileMatrix 3.0 - Algorytm RozwiƒÖzywania Kontekstu

*Dokument implementacyjny dla patcha PC3.0-2029-06*

## 1. Wprowadzenie do hierarchii kontekst√≥w

Hierarchia kontekst√≥w to kluczowy element standardu ProfileMatrix 3.0, umo≈ºliwiajƒÖcy precyzyjne okre≈õlanie preferencji w r√≥≈ºnych sytuacjach zawodowych. Niniejszy dokument formalizuje strukturƒô hierarchii, regu≈Çy dziedziczenia oraz algorytmy rozwiƒÖzywania konflikt√≥w kontekstowych.

### 1.1 Struktura hierarchii kontekst√≥w

Konteksty w ProfileMatrix 3.0 sƒÖ organizowane w hierarchicznƒÖ strukturƒô drzewa, gdzie bardziej szczeg√≥≈Çowe konteksty sƒÖ potomkami kontekst√≥w bardziej og√≥lnych:

```
@Work
  ‚îú‚îÄ‚îÄ @Work.Meeting
  ‚îÇ     ‚îú‚îÄ‚îÄ @Work.Meeting.Client
  ‚îÇ     ‚îú‚îÄ‚îÄ @Work.Meeting.Internal
  ‚îÇ     ‚îî‚îÄ‚îÄ @Work.Meeting.Team
  ‚îú‚îÄ‚îÄ @Work.Project
  ‚îÇ     ‚îú‚îÄ‚îÄ @Work.Project.Planning
  ‚îÇ     ‚îî‚îÄ‚îÄ @Work.Project.Execution
  ‚îî‚îÄ‚îÄ @Work.Personal
        ‚îú‚îÄ‚îÄ @Work.Personal.Focus
        ‚îî‚îÄ‚îÄ @Work.Personal.Development
```

### 1.2 Priorytetyzacja kontekst√≥w specjalnych

Niekt√≥re konteksty majƒÖ przypisane specjalne priorytety, kt√≥re zawsze zastƒôpujƒÖ konteksty standardowe:

| Typ kontekstu | Priorytet | Przyk≈Çady |
|--------------|-----------|-----------|
| Kryzysowy | 100 | @Crisis, @Emergency |
| Krytyczny | 80 | @Deadline, @Critical |
| Wa≈ºny | 60 | @Important, @Client |
| Standardowy | 40 | @Work, @Personal |
| Elastyczny | 20 | @Flexible, @Leisure |

## 2. Algorytm rozwiƒÖzywania kontekst√≥w

Poni≈ºej przedstawiamy formalny algorytm do rozwiƒÖzywania preferencji w przypadku nak≈ÇadajƒÖcych siƒô kontekst√≥w:

```typescript
/**
 * G≈Ç√≥wna funkcja rozwiƒÖzywania kontekstu dla preferencji
 * 
 * @param property Nazwa w≈Ça≈õciwo≈õci, dla kt√≥rej rozwiƒÖzujemy preferencjƒô
 * @param profile Pe≈Çny profil u≈ºytkownika
 * @param activeContexts Aktualnie aktywne konteksty
 * @returns RozwiƒÖzana warto≈õƒá preferencji lub null, je≈õli nie znaleziono
 */
function resolveContextualPreference(
  property: string,
  profile: Profile,
  activeContexts: Context[]
): PreferenceValue | null {
  // Sortujemy aktywne konteksty wed≈Çug priorytetu i specyficzno≈õci
  const sortedContexts = sortContextsByPriorityAndSpecificity(activeContexts);
  
  // Dla ka≈ºdego kontekstu, szukamy preferencji w kolejno≈õci priorytet√≥w
  for (const context of sortedContexts) {
    // 1. Sprawd≈∫ dok≈Çadne dopasowanie kontekstu dla tej w≈Ça≈õciwo≈õci
    const exactMatch = findExactPropertyContextMatch(property, profile, context);
    if (exactMatch) return exactMatch;
    
    // 2. Sprawd≈∫ konteksty nadrzƒôdne dla tego kontekstu
    const parentMatch = findMatchInParentContexts(property, profile, context);
    if (parentMatch) return parentMatch;
  }
  
  // 3. Je≈õli nie znaleziono dopasowania, szukaj w kontek≈õcie globalnym (bez kontekstu)
  const globalMatch = findGlobalPropertyMatch(property, profile);
  if (globalMatch) return globalMatch;
  
  // 4. Nie znaleziono ≈ºadnej pasujƒÖcej preferencji
  return null;
}

/**
 * Sortuje konteksty wed≈Çug priorytetu i specyficzno≈õci
 */
function sortContextsByPriorityAndSpecificity(contexts: Context[]): Context[] {
  return [...contexts].sort((a, b) => {
    // Najpierw sortuj wed≈Çug priorytet√≥w kontekst√≥w
    const priorityDiff = getContextPriority(b) - getContextPriority(a);
    if (priorityDiff !== 0) return priorityDiff;
    
    // Przy r√≥wnych priorytetach, bardziej specyficzne konteksty majƒÖ pierwsze≈Ñstwo
    return getContextSpecificity(b) - getContextSpecificity(a);
  });
}

/**
 * Zwraca priorytet kontekstu na podstawie jego typu
 */
function getContextPriority(context: Context): number {
  const contextPriorities: {[key: string]: number} = {
    'Crisis': 100,
    'Emergency': 100,
    'Deadline': 80,
    'Critical': 80,
    'Important': 60,
    'Client': 60,
    'Work': 40,
    'Personal': 40,
    'Flexible': 20,
    'Leisure': 20
  };
  
  // Sprawd≈∫ czy kontekst lub jego prefiks ma przypisany priorytet
  for (const [prefix, priority] of Object.entries(contextPriorities)) {
    if (context.name === prefix || context.name.startsWith(`${prefix}.`)) {
      return priority;
    }
  }
  
  // Domy≈õlny priorytet dla nieznanych kontekst√≥w
  return 30;
}

/**
 * Oblicza specyficzno≈õƒá kontekstu na podstawie g≈Çƒôboko≈õci w hierarchii
 */
function getContextSpecificity(context: Context): number {
  // Wiƒôcej poziom√≥w zagnie≈ºd≈ºenia oznacza wy≈ºszƒÖ specyficzno≈õƒá
  return context.name.split('.').length;
}

/**
 * Znajduje dok≈Çadne dopasowanie w≈Ça≈õciwo≈õci w danym kontek≈õcie
 */
function findExactPropertyContextMatch(
  property: string,
  profile: Profile,
  context: Context
): PreferenceValue | null {
  for (const segment of profile.segments) {
    for (const prop of segment.properties) {
      if (prop.key === property && 
          prop.context && 
          prop.context.name === context.name) {
        return prop.value;
      }
    }
  }
  return null;
}

/**
 * Znajduje dopasowanie w kontekstach nadrzƒôdnych
 */
function findMatchInParentContexts(
  property: string,
  profile: Profile,
  context: Context
): PreferenceValue | null {
  // Generuj wszystkie konteksty nadrzƒôdne (np. dla Work.Meeting.Client -> [Work.Meeting, Work])
  const parts = context.name.split('.');
  const parentContexts: string[] = [];
  
  for (let i = parts.length - 1; i > 0; i--) {
    parentContexts.push(parts.slice(0, i).join('.'));
  }
  
  // Sprawd≈∫ ka≈ºdy kontekst nadrzƒôdny w kolejno≈õci od najbardziej do najmniej specyficznego
  for (const parentName of parentContexts) {
    for (const segment of profile.segments) {
      for (const prop of segment.properties) {
        if (prop.key === property && 
            prop.context && 
            prop.context.name === parentName) {
          return prop.value;
        }
      }
    }
  }
  
  return null;
}

/**
 * Znajduje globalne dopasowanie w≈Ça≈õciwo≈õci (bez kontekstu)
 */
function findGlobalPropertyMatch(
  property: string,
  profile: Profile
): PreferenceValue | null {
  for (const segment of profile.segments) {
    for (const prop of segment.properties) {
      if (prop.key === property && !prop.context) {
        return prop.value;
      }
    }
  }
  return null;
}
```

## 3. Regu≈Çy dziedziczenia kontekstowego

Hierarchia kontekst√≥w w ProfileMatrix 3.0 podlega nastƒôpujƒÖcym regu≈Çom dziedziczenia:

### 3.1 Podstawowe regu≈Çy

1. **Dziedziczenie w d√≥≈Ç**: Konteksty potomne dziedziczƒÖ preferencje z kontekst√≥w nadrzƒôdnych, je≈õli nie posiadajƒÖ w≈Çasnej definicji.

2. **Przes≈Çanianie**: Konteksty potomne mogƒÖ przes≈Çaniaƒá preferencje z kontekst√≥w nadrzƒôdnych poprzez zdefiniowanie w≈Çasnych warto≈õci.

3. **Wielopoziomowe dziedziczenie**: Dziedziczenie dzia≈Ça przez dowolnƒÖ liczbƒô poziom√≥w hierarchii.

### 3.2 Przyk≈Çad dziedziczenia

```
// Podstawowe preferencje dla pracy
üíº@Work{üëî=üëï^3;üè¢=üè†^4;üëÇ=üîä^3}

// Specyficzne dla spotka≈Ñ - przes≈ÇaniajƒÖ czƒô≈õƒá preferencji, a inne dziedziczƒÖ
üíº@Work.Meeting{üëî=üëî^4;üëÇ=üîá^5}

// Specyficzne dla spotka≈Ñ z klientami - jeszcze bardziej specyficzne przes≈Çoniƒôcia
üíº@Work.Meeting.Client{üëî=üëî^5}
```

W tym przyk≈Çadzie:
- W kontek≈õcie `@Work.Meeting.Client`:
  - Preferencja ubioru (`üëî`) bƒôdzie `üëî^5` (zdefiniowana lokalnie)
  - Preferencja ha≈Çasu (`üëÇ`) bƒôdzie `üîá^5` (dziedziczona z `@Work.Meeting`)
  - Preferencja lokalizacji (`üè¢`) bƒôdzie `üè†^4` (dziedziczona z `@Work`)

## 4. RozwiƒÖzywanie konflikt√≥w kontekstowych

Przy nak≈ÇadajƒÖcych siƒô lub konkurujƒÖcych kontekstach stosuje siƒô nastƒôpujƒÖce strategie rozwiƒÖzywania konflikt√≥w:

### 4.1 Priorytetyzacja wed≈Çug wagi

Gdy ta sama w≈Ça≈õciwo≈õƒá jest zdefiniowana w wielu aktywnych kontekstach, warto≈õƒá z kontekstu o najwy≈ºszej wadze jest wybierana. Dotyczy to r√≥wnie≈º sytuacji, gdy konteksty majƒÖ te same priorytety i specyficzno≈õƒá:

```typescript
/**
 * RozwiƒÖzuje konflikty miƒôdzy kontekstami o tym samym priorytecie i specyficzno≈õci
 */
function resolveConflictsByWeight(
  property: string,
  profile: Profile,
  equalContexts: Context[]
): PreferenceValue | null {
  let maxWeight = -1;
  let bestValue = null;
  
  for (const context of equalContexts) {
    const propValue = findExactPropertyContextMatch(property, profile, context);
    
    if (propValue && propValue.weight > maxWeight) {
      maxWeight = propValue.weight;
      bestValue = propValue;
    }
  }
  
  return bestValue;
}
```

### 4.2 Agregacja warto≈õci z wielu kontekst√≥w

W niekt√≥rych przypadkach, warto≈õci z wielu kontekst√≥w mogƒÖ byƒá ≈ÇƒÖczone zamiast wybierania jednej z nich:

```typescript
/**
 * Agreguje warto≈õci z wielu kontekst√≥w dla w≈Ça≈õciwo≈õci wielowarto≈õciowych
 */
function aggregateMultiValuePreferences(
  property: string,
  profile: Profile,
  contexts: Context[]
): PreferenceValue[] | null {
  const aggregatedValues: {value: string, weight: number}[] = [];
  const seenValues = new Set<string>();
  
  // Sortuj konteksty wed≈Çug priorytetu i specyficzno≈õci
  const sortedContexts = sortContextsByPriorityAndSpecificity(contexts);
  
  // Zbierz unikalne warto≈õci ze wszystkich kontekst√≥w
  for (const context of sortedContexts) {
    const propValue = findExactPropertyContextMatch(property, profile, context);
    
    if (propValue) {
      // Obs≈Çuga wielu warto≈õci w pojedynczej preferencji
      const values = Array.isArray(propValue.values) 
        ? propValue.values 
        : [propValue.value];
      
      for (const val of values) {
        if (!seenValues.has(val)) {
          seenValues.add(val);
          aggregatedValues.push({
            value: val,
            weight: propValue.weight
          });
        }
      }
    }
  }
  
  // Sortuj wed≈Çug wagi i zwr√≥ƒá tylko warto≈õci
  return aggregatedValues
    .sort((a, b) => b.weight - a.weight)
    .map(item => item.value);
}
```

## 5. Przypadki testowe rozwiƒÖzywania kontekst√≥w

Poni≈ºej przedstawiamy przyk≈Çady rozwiƒÖzywania preferencji w r√≥≈ºnych scenariuszach kontekstowych:

### 5.1 Podstawowe przypadki testowe

```typescript
// Profil testowy
const testProfile = {
  segments: [
    {
      category: "üíº",
      properties: [
        { key: "üëî", value: "üëï", context: null }, // Domy≈õlny, bez kontekstu
        { key: "üëî", value: "üëî", context: { name: "Work" }, weight: 3 },
        { key: "üëî", value: "üëî", context: { name: "Work.Meeting" }, weight: 4 },
        { key: "üëî", value: "üëî", context: { name: "Work.Meeting.Client" }, weight: 5 },
        { key: "üè¢", value: "üè†", context: { name: "Work" }, weight: 4 },
        { key: "üëÇ", value: "üîä", context: { name: "Work" }, weight: 3 },
        { key: "üëÇ", value: "üîá", context: { name: "Work.Meeting" }, weight: 5 }
      ]
    }
  ]
};

// Przypadki testowe
const testCases = [
  {
    name: "Single active context",
    property: "üëî",
    activeContexts: [{ name: "Work" }],
    expectedValue: "üëî" // Z kontekstu Work
  },
  {
    name: "Hierarchy - child overrides parent",
    property: "üëî",
    activeContexts: [{ name: "Work.Meeting" }],
    expectedValue: "üëî" // Z kontekstu Work.Meeting (zastƒôpuje Work)
  },
  {
    name: "Hierarchy - parent used when not in child",
    property: "üè¢",
    activeContexts: [{ name: "Work.Meeting" }],
    expectedValue: "üè†" // Dziedziczone z Work, poniewa≈º nie zdefiniowano w Work.Meeting
  },
  {
    name: "Multiple contexts - most specific wins",
    property: "üëî",
    activeContexts: [{ name: "Work" }, { name: "Work.Meeting" }],
    expectedValue: "üëî" // Z Work.Meeting (bardziej specyficzny)
  },
  {
    name: "Multiple contexts with same specificity - highest weight wins",
    property: "üëÇ",
    activeContexts: [{ name: "Personal" }, { name: "Work" }],
    expectedValue: "üîä" // Z Work (Personal nie ma tej w≈Ça≈õciwo≈õci)
  },
  {
    name: "Fallback to global preference",
    property: "üëî",
    activeContexts: [{ name: "Personal" }],
    expectedValue: "üëï" // Globalna preferencja (bez kontekstu)
  },
  {
    name: "Special priority overrides specificity",
    property: "üëî",
    activeContexts: [{ name: "Work.Meeting" }, { name: "Client" }],
    expectedValue: "üëî" // Work.Meeting jest bardziej specyficzne, ale Client ma wy≈ºszy priorytet
  }
];
```

### 5.2 Z≈Ço≈ºone przypadki testowe

```typescript
// Przypadki z≈Ço≈ºone z nak≈ÇadajƒÖcymi siƒô kontekstami
const complexTestCases = [
  {
    name: "Multiple active hierarchical contexts",
    property: "üëî",
    activeContexts: [
      { name: "Work" }, 
      { name: "Work.Meeting" }, 
      { name: "Work.Meeting.Client" }
    ],
    expectedValue: "üëî", // Z Work.Meeting.Client (najbardziej specyficzny)
  },
  {
    name: "Conflict between high-priority and specific contexts",
    property: "üëî",
    activeContexts: [
      { name: "Work.Meeting.Client" }, // Najbardziej specyficzny
      { name: "Deadline" }            // Wysoki priorytet
    ],
    expectedValue: "üëî", // Deadline ma wy≈ºszy priorytet (80) ni≈º Work.Meeting.Client (40-60)
  },
  {
    name: "Emergency overrides everything",
    property: "üëî",
    activeContexts: [
      { name: "Work.Meeting.Client" },
      { name: "Deadline" },
      { name: "Emergency" }
    ],
    expectedValue: "üëî", // Emergency ma najwy≈ºszy priorytet (100)
  }
];
```

## 6. Zalecenia implementacyjne

1. **Wydajno≈õƒá**: Algorytm rozwiƒÖzywania kontekst√≥w mo≈ºe byƒá kosztowny dla du≈ºych profili z wieloma kontekstami. Rozwa≈º u≈ºycie buforowania i indeksowania do optymalizacji.

2. **Debugowanie**: Implementuj szczeg√≥≈Çowe informacje diagnostyczne dla deweloper√≥w, pokazujƒÖce jak zosta≈Çy rozwiƒÖzane poszczeg√≥lne preferencje.

3. **Dynamiczne konteksty**: Umo≈ºliw dynamiczne definiowanie i aktywowanie kontekst√≥w, zw≈Çaszcza w ≈õrodowiskach adaptacyjnych.

4. **Konflikty**: Implementuj strategie rozwiƒÖzywania konflikt√≥w z mo≈ºliwo≈õciƒÖ konfiguracji przez u≈ºytkownika.

5. **Skalowalno≈õƒá**: Projektuj z my≈õlƒÖ o rozszerzaniu struktury kontekst√≥w, dodawaniu nowych typ√≥w i priorytet√≥w.

## 7. Integracja z istniejƒÖcymi systemami

Algorytm rozwiƒÖzywania kontekst√≥w mo≈ºe byƒá wdro≈ºony w istniejƒÖcych systemach poprzez:

1. **API adaptacyjne**: Udostƒôpnianie interfejsu API, kt√≥ry przyjmuje aktywne konteksty i zwraca rozwiƒÖzane preferencje.

2. **Middleware kontekstowe**: Implementacja warstwy po≈õredniczƒÖcej, kt√≥ra automatycznie wykrywa kontekst i dostosowuje preferencje.

3. **Buforowanie profil√≥w kontekstowych**: Generowanie i buforowanie rozwiƒÖzanych profili dla czƒôsto u≈ºywanych kombinacji kontekst√≥w.

4. **Debugowanie**: Narzƒôdzia analizujƒÖce i wizualizujƒÖce proces rozwiƒÖzywania kontekst√≥w, pomagajƒÖce zar√≥wno u≈ºytkownikom jak i deweloperom.

Niniejszy dokument stanowi kompleksowƒÖ specyfikacjƒô algorytmu rozwiƒÖzywania kontekst√≥w dla standardu ProfileMatrix 3.0, zgodnie z wymaganiami okre≈õlonymi w poprawce PC3.0-2029-06.
